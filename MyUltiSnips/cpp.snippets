global !p
def getHandleMethod(baseClass, currentClass = ""):
	prefix = currentClass + '::' if currentClass != "" else ""
	if baseClass == "HttpHandlerJsonBase":
		return f"""Value {prefix}HandleRequestJsonThrow(const HttpRequest &request,
		const Value &request_json, RequestContext &context) const"""
	return f"""std::string {prefix}HandleRequestThrow(const HttpRequest &request,
                               RequestContext &context) const"""

def toUnderscore(line, sep='_'):
	def repl(match):
		return sep+match.group(0)

	return re.sub("[A-Z]", repl, line).lower()[1:]

def toDefine(line, suffix="_HPP_"):
	def repl(match):
		return "_"+match.group(0)

	return re.sub("[A-Z]", repl, line).upper()[1:] + suffix

def toDefine_inplace(line):
	return line.upper().replace(" ", "_")

def parseClassFields(fieldsText):
	fields = fieldsText.split(';');
	fieldsData = []
	for field in fields:
		if field == "":
			continue

		words = field.split(' ')
		fieldType, fieldName = ' '.join(words[:-1]), words[-1]
		fieldsData.append((fieldType, fieldName));

	return fieldsData

def classFieldsToConstructor(fieldsText):
	fieldsData = parseClassFields(fieldsText)
	result = ""
	for ftype, fname in fieldsData:
		if result == "":
			result += ftype + ' ' + fname.replace('_', '')
			continue
		result += ", " + ftype + ' ' + fname.replace('_', '')

	return result

def classFieldToAutoAssingInConstructor(fieldsText):
	fieldsData = parseClassFields(fieldsText)
	result = " : "
	for ftype, fname in fieldsData:
		if result == " : ":
			result += f"{fname}({fname.replace('_', '')})"
			continue
		result += ", " + f"{fname}({fname.replace('_', '')})"

	return result;

endglobal

extends c
priority 100

snippet fora "for(pre-init;auto:iterable)" wb
for($1 : $2) {
	$3
}
$0
endsnippet

snippet foral "for(pre-init;auto:iterable) on line" wb
for($1 : $2)
	$3
$0
endsnippet


snippet cl "class definition" wb
class ${1:ClassName} {
private:
	$2
public:
	$1(`!p snip.rv = classFieldsToConstructor(t[2])`)`!p snip.rv = classFieldToAutoAssingInConstructor(t[2])` {}
	$0
};
endsnippet

snippet cla "full one file class definition" wb
#ifndef `!p snip.rv = toDefine(t[1])`
#define `!p snip.rv = toDefine(t[1])`

class $1 {
private:
	$2
public:
	$1(`!p snip.rv = classFieldsToConstructor(t[2])`)`!p snip.rv = classFieldToAutoAssingInConstructor(t[2])` {}
	$0
};

#endif // !`!p snip.rv = toDefine(t[1])`
endsnippet


snippet name "namespace ... {}" wb
namespace $1 {
$0
} // namespace $1
endsnippet

snippet '([^a-zA-z])all' "std::begin(...), std::end(...)" ri
`!p snip.rv = match.group(1)`std::begin(${1:${VISUAL}}), std::end($1)$0
endsnippet

snippet cout "std::cout << ... << \n;" wb
std::cout << $2${1:<< '\n'};$0
endsnippet

snippet forit "for iterator" wb
for (
	${1:auto} it = ${2:std::begin($3)};
	it != ${4:std::end($3)};
	++it
) {
$0
}
endsnippet

snippet gtemplate "google tests main template" wb
#include <gtest/gtest.h>

int main(int argc, char **argw) {
	testing::InitGoogleTest(&argc, argw);
	return RUN_ALL_TESTS();
}
endsnippet

snippet gtest "google test" wb
TEST($1TestSuite, ${2:TestName}) {
	$0
}
endsnippet

snippet gftest "google fixture test" wb
TEST_F(${1:TestFixtureClassName}, ${2:TestName}) {
	$0
}
endsnippet

snippet gfclass "google fixture class" wb
#include <gtest/gtest.h>

class $1 : public testing::Test {
	public:
	void SetUp() {}
	void TearDown() {}
};
endsnippet

snippet gpclass "google parametrized class" wb
#include <gtest/gtest.h>

class $1 : public testing::TestWithParam<$2> {
	public:
	void SetUp() {}
	void TearDown() {}
};

INSTANTIATE_TEST_SUITE_P(${3:GroupName}, $1, ${4:testing::Values($5)});
TEST_P($1, ) {
	$2 param = GetParam();
}
endsnippet

snippet gptest "google parametrized test" wb
TEST_P(${1:TestFixtureClassName}, ${2:TestName}) {
	$0
}
endsnippet

snippet clint "class interface definition" wb
class I$1 {
public:
	virtual ${4:void} ${2:method} ($3) = 0;
};
endsnippet

snippet tem "template <typename ...>" wb
template <${1:typename} ${2:T}$3>$0
endsnippet

snippet cnstr "default constructors" wb
$1()${2: = default};
${3:`!p snip.rv = \
t[1] + "(const " + t[1]+" &other);\n" +\
t[1]+"("+t[1] + " &&other) noexcept;\n" + \
t[1] + "& operator=(const "+t[1]+ "&other);\n" + \
t[1]+"& operator=("+t[1]+" &&other) noexcept;"`}
$0
endsnippet

snippet method "method outline" wb
${1:tem$2}
${3:retVal} ${4:className}::${5:method}($6) {
$0
}
endsnippet

snippet sample "sample" wb
some $1
none $1
$0
endsnippet


snippet iterDef "iterator definition" wb
template <typename ${1:T}>
class ${2:Iterator} {
public:
	using iterator_category = ${3:std::bidirectional_iterator_tag};
	using difference_type = ${4:std::ptrdiff_t};
	using value_type = `!p snip.rv = t[1]`;
	using pointer = `!p snip.rv = t[1]` *;
	using reference = `!p snip.rv = t[1]` &;

protected:
	${5:$1*} ptr_;

public:
	$2($5 ptr) : ptr_(ptr) {}

	reference operator*() { return *ptr_; }
	pointer operator->() { return ptr_; }

	bool operator==(const $2<$1> &other) const {
		return ptr_ == other.ptr_;
	}

	// prefix
	$2<$1> &operator++() {
		// TODO
	}

	// postfix
	$2<$1> operator++(int) {
		$2<$1> result(ptr_);
		++(*this);
		return result;
	}

	$2<$1> &operator--() {
		// TODO
	}

	$2<$1> operator--(int) {
		$2<$1> result(ptr_);
		--(*this);
		return result;
	}

	$2<$1> operator+(difference_type diff) const {
		// TODO
	}

	$2<$1> operator-(difference_type diff) const {
		// TODO
	}

	difference_type operator-(const $2<$1> & other) const {
		// TODO
	}
};
endsnippet

snippet ushandler "userver handler template" w
#ifndef HANDLER_`!p snip.rv = toDefine(t[2])`
#define HANDLER_`!p snip.rv = toDefine(t[2])`
#pragma once

#include <userver/server/handlers/`!p snip.rv = toUnderscore(t[3])`>

namespace ${1:SERVICE_NAMESPACE} {
using namespace userver;
class ${2:Handler} final : public server::handlers::${3|HttpHandlerBase,HttpHandlerJsonBase|} {
public:
	constexpr static std::string_view kName = "`!p snip.rv = toUnderscore(t[2], '-')`";

	using HttpRequest = server::http::HttpRequest;
	using RequestContext = server::request::RequestContext;
	`!p snip.rv = "using Value = formats::json::Value;" if t[3] == "HttpHandlerJsonBase" else ""`
	`!p snip.rv = f"using {t[3]}:{t[3]};" if len(t[4]) < 10 else ""`

	${4:$2(const components::ComponentConfig &config,
                  const components::ComponentContext &component_context);}

	`!p snip.rv = getHandleMethod(t[3])` override;
};
} // !$1

#endif // !HANDLER_`!p snip.rv = toDefine(t[2])`

// HEADER PART ENDS
// CPP SOURCE PART BEGIN(place part below to cpp source file)
#include "${5:handlers/}${6:`!p snip.rv = t[2].lower()[:-7] if t[2].endswith("Handler") else t[2].lower()`}.hpp"

namespace $1 {
`!p snip.rv = (f"{t[4][:-1]}\n\t: {t[3]}" + r"(config, component_context) {}") if len(t[4]) > 10 else ""`

`!p snip.rv = (f"{t[2]}::" if t[3] == "HttpHandlerJsonBase" else "") + getHandleMethod(t[3], t[2]) + r" {}"`
} // !$1
endsnippet
